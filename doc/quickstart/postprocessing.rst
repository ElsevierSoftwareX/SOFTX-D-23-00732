.. include:: ../substitutions.rst

==============
Postprocessing
==============

TL;DR
^^^^^

The ``postprocess.py`` command-line tool can be used to analyze the results generated by ``match_template.py``.

.. code-block:: bash

    postprocess.py --help

.. tab-set::

    .. tab-item:: Extract Orientations

        Executing the following code will generate a tab-separated file named `output.tsv` with eight columns. The z, y and x column correspond to the translation, the euler_z, euler_y and euler_x column to the rotation used to obtain the column score. The detail column provides some additional information based on the process with which the peaks were generated.

        The peaks are separated by 20 voxels and no more than 1,000 peaks will be written to disk.

        .. code-block:: bash

            postprocess.py \
                --input_file output.pickle \
                --output_prefix output \
                --output_format orientations \
                --min_distance 20 \
                --number_of_peaks 1000

    .. tab-item:: Extract Alignments

        Executing the following code will align the template to the target used in ``match_template.py`` based on high-scoring orientations. These high-scoring orientations are written to disk, either as atomic structure or density depending on which was used as input for ``match_template.py``. The generated files follow the naming pattern {output_prefix}.{index}.{extension}. In the following example output_prefix would be output. Index 0 corresponds to the orientation with highest score, index 1 to the second largest and so on. Extension corresponds to the file extension of the template used in ``match_template.py``.

        The following will write no more than ten top scoring alignments
        to disk.

        .. code-block:: bash

            postprocess.py \
                --input_file output.pickle \
                --output_prefix output \
                --output_format alignment \
                --number_of_peaks 10

    .. tab-item:: Extract Particles

        Executing the following code will extract regions from the target with the dimension of the template used in ``match_template.py``. The output can be used for alignment and or averaging. The generated files follow the naming pattern {output_prefix}.{index}.mrc. In the following example output_prefix would be output. Index 0 corresponds to the orientation with highest score, index 1 to the second largest and so on.


        The following will write no more than 500 top scoring particles separated by a distance of 20 voxel that have been identified using :py:class:`tme.analyzer.PeakCallerMaximumFilter` to disk.

        to disk.

        .. code-block:: bash

            postprocess.py \
                --input_file output.pickle \
                --output_prefix output \
                --output_format extraction \
                --min_distance 20 \
                --number_of_peaks 500 \
                --peak_caller PeakCallerMaximumFilter


Template Matching Result
^^^^^^^^^^^^^^^^^^^^^^^^

The output of ``match_template.py`` is a pickle file that contains the output of the analyzer used on the scores, which by default is :py:class:`tme.analyzer.MaxScoreOverRotations`. The pickle file can be read using :py:meth:`tme.matching_utils.load_pickle` and contains five objects:

- **Scores Array**: A numpy array with scores mapped to translations.
- **Translation Offset**: A translation offset informing about shifts in coordinate sytems.
- **Rotations Array**: A numpy array detailing rotations connected to the scores from specific translations.
- **Rotation-Euler Dictionary**: A mapping of rotations to their corresponding Euler angles.
- **Metadata**: Coordinate system information relevant to subsequent analysis as well as all parameters that were used to enable reproducibility.


For those familiar with other tools, the output aligns with what's seen in `STOPGAP <https://github.com/williamnwan/STOPGAP>`_, `PyTom <https://github.com/FridoF/PyTom>`_ and `Situs colores <https://situs.biomachina.org/fguide.html#colores>`_.


However, when you employ the `-p` flag with ``match_template.py``, the output structure differs. The flag triggers direct peak calling, altering the output to include:

- **Translations**: A numpy array containing translations with shape `number_peaks x dimensions`.
- **Rotations**: A numpy array containing rotations with shape `number_peaks x dimensions x dimensions`.
- **Scores**: The scoring values for each peak, defined by its translation and rotation.
- **Details**: Additional information regarding each peak.
- **Metadata**: Coordinate system information relevant to subsequent analysis as well as all parameters that were used to enable reproducibility.

Converting scores into orientations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Based on the output of ``match_template.py``, we can now extract orientations where the template best represents the targets by using one of the peak calling functionalities in :ref:`analyzer-label`. For demonstration, we will used :py:class:`tme.analyzer.PeakCallerScipy` to identify a maximum of 1000 local maxima that are separated by a distance of 5 voxel. Typically it makes sense to set the minimum distance to the smallest dimension of the template. The following code assumes that ``match_template.py`` generated the file ``output.pickle`` and will generated a file output.tsv that contains the translation, euler angles and scores.

.. code-block:: python

    import pickle
    import numpy as np
    from tme.analyzer import PeakCallerScipy
    from tme.matching_utils import load_pickle

    # Loading ``match_template.py`` output.
    data = load_pickle("output.pickle")

    scores, offset, rotations, rotation_mapping, *_ = data

    # Calling peaks on score array
    peak_caller = PeakCallerScipy(
        number_of_peaks = 1000,
        min_distance = 5
    )
    peak_caller(scores, rotation_matrix = np.eye(3))
    candidates = tuple(peak_caller)

    # Writing orientations to disk
    header = "\t".join(["z", "y", "x", "euler_z", "euler_y", "euler_x", "score", "detail"])
    with open("output.tsv", mode = "w", encoding = "utf-8") as ofile:
        _ = ofile.write(f"{header}\n")
        for translation, _, score, detail in zip(*candidates):
            angles = rotation_mapping[rotations[tuple(translation)]]
            translation_string = "\t".join([str(x) for x in translation])
            angle_string = "\t".join([str(x) for x in angles])
            _ = ofile.write(f"{translation_string}\t{angle_string}\t{score}\n")

.. note::

    The determined candidates heavily depend on the used analyzer. For more details on available analzyers please refer to :ref:`analyzer-label`. In addition, peak calling can also be performed directly without the need for score aggregation using ``match_template.py``'s ``-p`` option, which will be covered in a different tutorial.


Each line in ``output.tsv`` corresponds to a distinct orientation of the template in the target. The coordinate columns z, y and x indicate the position of the template's center of mass in the target, while euler_z, euler_y and euler_x contain the euler angles used for rotation. Score corresponds to the score of the orientation defined by translation and rotation and detail to auxiliary information relevant to certain peak callers.

Usage Examples
~~~~~~~~~~~~~~

The following outlines how to use ``output.tsv`` for the previous section's :ref:`Usage Examples <cli-match_template>`.

.. tab-set::

    .. tab-item:: Particle Picking

        In the case of particle picking its usually sufficient to look at the rotations in a viewer like `IMOD <https://bio3d.colorado.edu/imod/>`_. The following assumes that you have IMOD installed and its command line tools linked.

        .. code-block:: bash

            awk -F'\t' '
                BEGIN {OFS="\t"}
                NR==1 {next}
                {print 1, 1, $3, $2, $1}
            ' output.tsv > coordinates.tsv

            point2model -inp coordinates.tsv -ou coordinates.mod -ci 10


    .. tab-item:: Fit Atomic Structure

        For this case, its common to inspect the positioning of the initial structure after translation and rotation in the electron density. The following transforms the initial structure and writes the top ten highest scoring candidates to disk.

        .. code-block:: python

            import pickle

            import numpy as np

            from tme import Density, Structure
            from tme.matching_utils import euler_to_rotationmatrix, load_pickle

            # Load and extract orientations
            orientations = []
            with open("output.tsv", mode = "r", encoding = "utf-8") as infile:
                data = infile.read().split("\n")

            # Remove header
            _ = data.pop(0)

            # Get coordinate system information
            target_origin, _, sampling_rate, meta = load_pickle("output.pickle").pop()

            # Convert string to floating point
            for orientation in data:
                orientation = orientation.split("\t")
                if len(orientation) == 1:
                    continue
                orientations.append([float(x) for x in orientation])

            # Load template and compute center of mass
            initial_structure = Structure.from_file("5UZ4.pdb")
            center_of_mass = initial_structure.center_of_mass()[::-1]

            # Generate candidates and write to disk
            n_candidates = min(10, len(orientations))
            for i in range(n_candidates):
                orientation = orientations[i]
                translation, rotation = orientation[0:3], orientation[3:6]
                translation = np.subtract(
                    np.multiply(translation, sampling_rate),
                    center_of_mass,
                )
                translation = np.add(translation, target_origin)
                rotation_matrix = euler_to_rotationmatrix(rotation)
                transformed_structure = initial_structure.rigid_transform(
                    translation = translation[::-1],
                    rotation_matrix = rotation_matrix[::-1, ::-1]
                )
                transformed_structure.to_file(f"{i}.pdb")


    .. tab-item:: Alignment of Densities

        The following transforms the initial density and writes the top ten highest scoring candidates to disk.

        .. code-block:: python

            import pickle

            import numpy as np

            from tme import Density
            from tme.matching_utils import euler_to_rotationmatrix, load_pickle

            # Load and extract orientations
            orientations = []
            with open("output.tsv", mode = "r", encoding = "utf-8") as infile:
                data = infile.read().split("\n")

            # Remove header
            _ = data.pop(0)

            # Get coordinate system information
            target_origin, _, sampling_rate, meta = load_pickle("output.pickle").pop()

            # Convert string to floating point
            for orientation in data:
                orientation = orientation.split("\t")
                if len(orientation) == 1:
                    continue
                orientations.append([float(x) for x in orientation])

            # Load template and compute center of mass
            initial_density = Density.from_file("emd_8621_transformed.mrc")
            initial_density, _ = initial_density.centered(0)
            center_of_mass = initial_density.center_of_mass(initial_density.data)

            n_candidates = min(10, len(orientations))
            for i in range(n_candidates):
                orientation = orientations[i]
                translation, rotation = orientation[0:3], orientation[3:6]
                translation = np.subtract(translation, center_of_mass)
                rotation_matrix = euler_to_rotationmatrix(rotation)
                transformed_density = initial_density.rigid_transform(
                    rotation_matrix = rotation_matrix
                )
                new_origin = np.add(target_origin / sampling_rate, translation)
                transformed_density.origin = np.multiply(new_origin, sampling_rate)
                transformed_density.to_file(f"{i}.mrc")



Coordinate System Convention
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The convention used in |project| to represent in scores and candidates is analogous to other tools and figuratively explained in a `skimage tutorial <https://scikit-image.org/docs/stable/auto_examples/features_detection/plot_template.html>`_. Assuming a peak in the score space or a candidate at position (50,50,50) and the template center of mass at (15,15,15), the translation of the template to acqquire a given score is calculated as their difference, e.g. the template has to be translated by (35,35,35), or the center of mass moved to (50,50,50).

Different conventions are used to express rotations and translations. |project| centeres rotations around the center of mass and applies translations subsequently by default. ``match_template.py`` follows this default behaviour.
